#!/usr/bin/env bash

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}" )" > /dev/null && pwd)"
MAIN_COMMAND=$(basename ${0})
SUBCOMMANDS_DIR=${ROOT_DIR}/${MAIN_COMMAND}.d

DEBUG=$(eval "[[ -n \${${MAIN_COMMAND^^}_DEBUG} ]] && echo 'true' ")

# add itself to PATH if needed
type -a ${MAIN_COMMAND} &> /dev/null
[[ $? != 0 ]] && export PATH=${PATH}:${ROOT_DIR}

function _colored()   { tput -Txterm setaf ${1}; echo -e ${2}; tput -Txterm sgr0; }
function in_red()     { _colored 1 "${1}"; } # use for failures
function in_green()   { _colored 2 "${1}"; } # use for successes
function in_yellow()  { _colored 3 "${1}"; } # use for warnings / attention
function in_magenta() { _colored 5 "${1}"; } # use for debug messages
function in_cyan()    { _colored 6 "${1}"; } # use for main actions / progress

function log() {
  if [[ -n ${DEBUG} ]]; then
    tput -Txterm setaf 5 >&2
    echo -e "debug: ${*}" >&2
    tput -Txterm sgr0 >&2
  fi
}

function _check_bash_version() {
 if [[ ${BASH_VERSION%%.*} -lt 4 ]]; then
  in_yellow "WARNING: bash version is '${BASH_VERSION}'"
  in_yellow "WARNING: which is less than version 4."
  in_yellow "WARNING: Not all scripts and commands will work properly."
  in_yellow "WARNING: Consider installing a more recent version of bash."
 fi
}

function _list_commands()
{
  echo
  echo "Subcommands available ('${MAIN_COMMAND} SUBCOMMAND help' for usage):"
  echo
  for i in $(export LC_COLLATE=C; ls ${SUBCOMMANDS_DIR}/* | grep -vE '/_[^[:blank:]]+$' | sort); do
    echo -e "  $(basename ${i}):\t\t$(source "${i}" && echo ${SUBCOMMAND_DESC})"
  done
  echo
  exit 1
}

function _subcommand_help() {
    local subcmd=${1}
    local subhelp=${2}
    echo
    echo "Showing '${MAIN_COMMAND} ${subcmd}' available actions"
    echo
    echo "${subhelp}"
    echo
    exit 1
}

function _help() {
  _subcommand_help ${SUBCOMMAND} "${SUBCOMMAND_HELP}"
}

function error() {
  in_red "Error: ${1}"
  exit 1
}

function use() {
  . ${SUBCOMMANDS_DIR}/_${1}
}

function random_hex() {
  local chars=${1:-32}
  echo $(cat /dev/urandom | env LC_CTYPE=C tr -cd 'a-f0-9' | head -c ${chars})
}

function stop_process() {
  local appname="${*}"
  local pid=$(pgrep -f "${appname}")
  log "stop process:${appname} (${pid})"
  pkill -f "${appname}" &> /dev/null
  [[ -z ${pid} ]] && return
  while kill -0 "${pid}" &> /dev/null; do
    log "waiting process:${appname} (${pid}) stop"
    sleep 1; ((limit++))
    [[ ${limit} -gt 10 ]] && in_red "Timeout stopping (${appname})" && break
  done
}

function _handle_subcommand() {
  local SUBCOMMAND=${1}; shift 1
  local ACTION="${@}"

  log "running ${SUBCOMMANDS_DIR}/${SUBCOMMAND} ${ACTION} "
  . "${SUBCOMMANDS_DIR}/${SUBCOMMAND}" ${ACTION}

  if [[ "${ACTION}" == "help" || -z "${ACTION}" ]]; then
    log "showing '${SUBCOMMAND}' help"
    _help
  fi
}

_check_bash_version # warn user of old bash installations

_arg_subcmd=${1}
case ${_arg_subcmd} in
  help|-h|-?|--help|'')
    log 'help or no argument was given'
    _list_commands
    ;;
  *)
    log "arguments '${*}'"
    log "checking if '${SUBCOMMANDS_DIR}/${_arg_subcmd}' exists"
    [[ ! -f "${SUBCOMMANDS_DIR}/${_arg_subcmd}" ]] && in_red "'${_arg_subcmd}' not found" && _list_commands
    shift 1
    _handle_subcommand ${_arg_subcmd} "${@}"
    ;;
esac

